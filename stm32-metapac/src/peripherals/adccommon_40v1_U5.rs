

# [doc = "Analog-to-Digital Converter"]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct AdcCommon { ptr : * mut u8 } unsafe impl Send for AdcCommon { } unsafe impl Sync for AdcCommon { } impl AdcCommon { # [inline (always)]
pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)]
pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "ADC common control register"]
# [inline (always)]
pub const fn ccr (self) -> crate :: common :: Reg < regs :: Ccr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . add (0usize) as _) } } } pub mod regs { # [doc = "ADC common control register"]
# [repr (transparent)]
# [derive (Copy , Clone , Eq , PartialEq)]
pub struct Ccr (pub u32) ; impl Ccr { # [doc = "ADC prescaler"]
# [inline (always)]
pub const fn presc (& self) -> super :: vals :: Presc { let val = (self . 0 >> 18usize) & 0x0f ; super :: vals :: Presc :: from_bits (val as u8) } # [doc = "ADC prescaler"]
# [inline (always)]
pub fn set_presc (& mut self , val : super :: vals :: Presc) { self . 0 = (self . 0 & ! (0x0f << 18usize)) | (((val . to_bits () as u32) & 0x0f) << 18usize) ; } # [doc = "VREFINT enable"]
# [inline (always)]
pub const fn vrefen (& self) -> bool { let val = (self . 0 >> 22usize) & 0x01 ; val != 0 } # [doc = "VREFINT enable"]
# [inline (always)]
pub fn set_vrefen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize) ; } # [doc = "Temperature sensor enable"]
# [inline (always)]
pub const fn vsenseen (& self) -> bool { let val = (self . 0 >> 23usize) & 0x01 ; val != 0 } # [doc = "Temperature sensor enable"]
# [inline (always)]
pub fn set_vsenseen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize) ; } # [doc = "VBAT enable"]
# [inline (always)]
pub const fn vbaten (& self) -> bool { let val = (self . 0 >> 24usize) & 0x01 ; val != 0 } # [doc = "VBAT enable"]
# [inline (always)]
pub fn set_vbaten (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize) ; } } impl Default for Ccr { # [inline (always)]
fn default () -> Ccr { Ccr (0) } } } pub mod vals { # [repr (u8)]
# [derive (Copy , Clone , Eq , PartialEq , Ord , PartialOrd)]
pub enum Presc { # [doc = "adc_ker_ck_input not divided"]
DIV1 = 0 , # [doc = "adc_ker_ck_input divided by 2"]
DIV2 = 0x01 , # [doc = "adc_ker_ck_input divided by 4"]
DIV4 = 0x02 , # [doc = "adc_ker_ck_input divided by 6"]
DIV6 = 0x03 , # [doc = "adc_ker_ck_input divided by 8"]
DIV8 = 0x04 , # [doc = "adc_ker_ck_input divided by 10"]
DIV10 = 0x05 , # [doc = "adc_ker_ck_input divided by 12"]
DIV12 = 0x06 , # [doc = "adc_ker_ck_input divided by 16"]
DIV16 = 0x07 , # [doc = "adc_ker_ck_input divided by 32"]
DIV32 = 0x08 , # [doc = "adc_ker_ck_input divided by 64"]
DIV64 = 0x09 , # [doc = "adc_ker_ck_input divided by 128"]
DIV128 = 0x0a , # [doc = "adc_ker_ck_input divided by 256"]
DIV256 = 0x0b , _RESERVED_c = 0x0c , _RESERVED_d = 0x0d , _RESERVED_e = 0x0e , _RESERVED_f = 0x0f , } impl Presc { # [inline (always)]
pub const fn from_bits (val : u8) -> Presc { unsafe { core :: mem :: transmute (val & 0x0f) } } # [inline (always)]
pub const fn to_bits (self) -> u8 { unsafe { core :: mem :: transmute (self) } } } impl From < u8 > for Presc { # [inline (always)]
fn from (val : u8) -> Presc { Presc :: from_bits (val) } } impl From < Presc > for u8 { # [inline (always)]
fn from (val : Presc) -> u8 { Presc :: to_bits (val) } } }